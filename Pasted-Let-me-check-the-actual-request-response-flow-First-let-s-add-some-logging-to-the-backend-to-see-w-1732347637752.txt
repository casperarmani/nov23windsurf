Let me check the actual request/response flow. First, let's add some logging to the backend to see what's happening:

Edit:
app.py
+14
-2
 665
Preview
Apply
{{ ... }}
@app.post("/chat_sessions")
async def create_chat_session(
    session: ChatSession,
    user: dict = Depends(get_current_user)
) -> JSONResponse:
    """Create a new chat session for the user."""
    try:
        logger.info(f"Creating chat session for user {user['id']} with title {session.title}")
        result = await db.create_chat_session(user['id'], session.title)
        logger.info(f"Created chat session: {result}")
        return JSONResponse(content=result)
    except Exception as e:
        logger.error(f"Error creating chat session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/chat_history")
async def get_chat_history(
    session_id: Optional[str] = None,
    user: dict = Depends(get_current_user)
) -> JSONResponse:
    """Get chat history for a specific session or all sessions."""
    try:
        logger.info(f"Getting chat history for user {user['id']}, session {session_id}")
        messages = await db.get_chat_history(user['id'], session_id)
        logger.info(f"Found {len(messages)} messages")
        return JSONResponse(content={"history": messages})
    except Exception as e:
        logger.error(f"Error getting chat history: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/send_message")
async def send_message(
    request: Request,
    message: str = Form(...),
    session_id: Optional[str] = None,
    videos: Optional[List[UploadFile]] = File(None),
    user: dict = Depends(get_current_user)
) -> JSONResponse:
    """Send a message and optionally process videos in a chat session."""
    try:
        logger.info(f"Sending message for user {user['id']}, session {session_id}")
        logger.info(f"Message content: {message}")
        logger.info(f"Videos: {videos}")
        
        # Process videos if provided
        video_response = None
        if videos and len(videos) > 0:
            for video in videos:
                content = await video.read()
                file_id = str(uuid.uuid4())
                await redis_storage.store_file(file_id, content)
                video_response = await chatbot.analyze_video(file_id, video.filename)

        # Process the chat message
        chat_response = await chatbot.send_message(message)
        final_response = video_response if video_response else chat_response
        
        # Save the conversation to the database with session_id
        await db.save_chat_message(user['id'], message, final_response, session_id)
        logger.info(f"Message saved, response: {final_response}")
        
        return JSONResponse(content={"response": final_response})
    except Exception as e:
        logger.error(f"Error processing message: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
{{ ... }}
Now let's check the database implementation:

Analyzed

database.py
I see several issues:

Let's fix the chat history retrieval in App.tsx:
Edit:
App.tsx
+8
-21
 115
Preview
Apply
{{ ... }}
  const fetchHistories = async () => {
    try {
      const response = await fetch(`/chat_history${currentChatId ? `?session_id=${currentChatId}` : ''}`, {
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Failed to fetch chat history');
      }

      const data = await response.json();
      setChatHistory(data.history || []);
    } catch (error) {
      console.error('Error fetching histories:', error);
      setError(error instanceof Error ? error.message : 'An error occurred while fetching data');
    }
  };

  useEffect(() => {
    fetchHistories();
  }, [currentChatId]);  // Re-fetch when chat ID changes
{{ ... }}
Let's fix the ChatContainer to properly handle messages and send them to the correct session:
Edit:
ChatContainer.tsx
+18
-12
 160
Preview
Apply
{{ ... }}
function ChatContainer({ initialMessages = [], onCreateSession }: ChatContainerProps) {
  const { currentSession, messages, isLoading, sendMessage, setMessages } = useChat();
  const [message, setMessage] = useState<string>('');
  const [files, setFiles] = useState<File[]>([]);
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const dropZoneRef = useRef<HTMLDivElement>(null);

  // Initialize messages from chat history
  useEffect(() => {
    if (initialMessages?.length > 0) {
      setMessages(initialMessages);
    }
  }, [initialMessages]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() && files.length === 0) return;

    const formData = new FormData();
    formData.append('message', message);
    if (currentSession?.id) {
      formData.append('session_id', currentSession.id);
    }
    files.forEach(file => formData.append('videos', file));

    try {
      await sendMessage(formData);
      setMessage('');
      setFiles([]);
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

{{ ... }}
Let's update the ChatContext to properly handle sessions and messages:
Edit:
ChatContext.tsx
+27
-31
 85
Preview
Apply
{{ ... }}
export function ChatProvider({ children }: { children: ReactNode }) {
  const [currentSession, setCurrentSession] = useState<ChatSession | null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const sendMessage = async (formData: FormData) => {
    setIsLoading(true);
    try {
      const response = await fetch('/send_message', {
        method: 'POST',
        body: formData,
        credentials: 'include',
      });

      if (!response.ok) {
        throw new Error('Failed to send message');
      }

      const data = await response.json();
      const userMessage: Message = {
        id: Date.now().toString(),
        content: formData.get('message') as string,
        type: 'user',
        timestamp: new Date().toISOString()
      };
      
      const botMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: data.response,
        type: 'bot',
        timestamp: new Date().toISOString()
      };

      setMessages(prev => [...prev, userMessage, botMessage]);
    } catch (error) {
      console.error('Error sending message:', error);
      setError(error instanceof Error ? error.message : 'Failed to send message');
    } finally {
      setIsLoading(false);
    }
  };

  const clearError = () => setError(null);

  const value = {
    currentSession,
    messages,
    isLoading,
    error,
    sendMessage,
    clearError,
    setMessages,
    setCurrentSession
  };

  return <ChatContext.Provider value={value}>{children}</ChatContext.Provider>;
}
{{ ... }}
The key issues were:

Chat history wasn't being fetched with the correct session_id
Messages weren't being sent with the session_id
ChatContext wasn't properly handling message state
The changes I've made should fix these issues by:

Properly fetching chat history with session_id
Including session_id when sending messages
Correctly managing message state in ChatContext
Adding proper error handling and logging